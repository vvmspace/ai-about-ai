# Системная архитектура простыми словами: время, стоимость, риск

Архитектурные интервью очень быстро становятся театром.
Большие диаграммы.
Громкие слова.
Почти нулевая ответственность.

Я в эту игру не играю.
Я формулирую архитектуру как управляемые компромиссы в рамках ограничений.
Время.
Стоимость.
Риск.

Если я не могу ясно назвать эти три пункта, я не проектирую.
Я декорирую.

Мой первый ход в system design — всегда уточнение.

“I’m curious—what matters most for this scenario: latency, reliability, or implementation speed?”
[Мне любопытно: что в этом сценарии важнее всего — задержка, надёжность или скорость реализации?]

Один вопрос выставляет рамку переговоров.
И защищает от «элегантного, но нерелевантного» ответа.

## Мой 7-шаговый поток ответа по архитектуре

1. Уточнить продуктовую цель и метрику успеха.
2. Выделить главное ограничение (масштаб, latency, compliance, размер команды).
3. Предложить базовую архитектуру, а не финальное совершенство.
4. Отметить точки отказа и узкие места.
5. Добавить observability и пути восстановления.
6. Явно проговорить trade-off.
7. Показать поэтапный путь эволюции.

Интервьюеры обычно расслабляются, когда слышат фазовое мышление.
Оно подразумевает реализм.

## Modular monolith vs microservices

Я отвечаю без романтики.

Modular monolith чаще всего лучше, когда:

- Команда маленькая или средняя.
- Границы домена ещё формируются.
- Быстрая итерация важнее независимого масштабирования.
- Операционный бюджет ограничен.

Microservices становятся оправданными, когда:

- У разных доменов разные профили масштабирования.
- Команды могут владеть сервисами end-to-end.
- Операционная зрелость поддерживает distributed tracing, resilience и governance.
- Изоляция отказов — это бизнес-требование, а не предпочтение.

Если дробим слишком рано, сложность приходит раньше ценности.
Если дробим слишком поздно, связность начинает облагать рост налогом.
Время имеет значение.

## Согласованность данных: практичный язык

Я делаю решения по consistency явными.
Для критичных денежных операций strict consistency обычно не обсуждается.
Для аналитических дашбордов eventual consistency часто приемлема.

Я говорю это на интервью прямо:

“Strong consistency where legal or financial correctness is required.
Eventual consistency where user experience tolerates slight lag and throughput matters more.”
[Сильная согласованность там, где требуется юридическая или финансовая корректность.
Eventual consistency там, где пользовательский опыт допускает небольшую задержку, а throughput важнее.]

Потом добавляю механизмы.
Outbox pattern.
Idempotent consumers.
Dead-letter queues.
Replay tooling.

В такой связке ответ звучит меньше теоретически и больше деплоебельно.

## Сценарий: дизайн matching-платформы

Представим, мы проектируем AI-assisted matching-систему с ingest профилей, генерацией embeddings и ранжированными рекомендациями.

Я бы стартовал с modular monolith плюс async-конвейеры:

- API-слой для profile CRUD и search-запросов.
- Worker-пайплайн для генерации embeddings.
- Vector store для semantic retrieval.
- Ranking-слой, который объединяет vector score и бизнес-правила.
- Cache-слой для «горячих» путей рекомендаций.

Модель отказов:

- Отказ embedding-сервиса должен деградировать в lexical search, а не в полный outage.
- Лаг очереди должен поднимать алерты до нарушения SLA.
- Частичные обновления профиля должны быть idempotent и replayable.

Путь эволюции:

- С первого дня изолировать ranking и ingestion-модули.
- Делить на отдельные сервисы только когда это требует throughput или ownership команды.

Формулировка trade-off:

“We accept temporary coupling now to reduce time-to-market, while preserving extraction seams for future service boundaries.”
[Мы принимаем временную связность сейчас, чтобы сократить time-to-market, сохраняя при этом швы для будущего выделения сервисных границ.]

Это и есть практичная архитектура.

## Контроль стоимости в AI-heavy системах

Сейчас этот вопрос звучит часто.
Я отвечаю в операционных терминах:

- Кешировать частые промпты и детерминированные ответы, где это возможно.
- Использовать tiered model routing по критичности задачи.
- Считать стоимость на успешный workflow, а не только на API-call.
- Добавлять evaluation gates до расширения использования моделей.

Как ни крути, архитектура без видимости стоимости неполна.

## Позиция по надёжности, на которой я настаиваю

Для избежания двусмысленности: я не называю систему production-ready без следующих пунктов:

- SLO, привязанные к пользовательским исходам.
- Runbooks для топ-инцидентов.
- Стратегия rollback или feature flags.
- Evidence нагрузочного тестирования под ожидаемые пики.
- Модель on-call ownership.

Может звучать строго.
Зато предотвращает предсказуемый хаос.

## Шаблон ответа для интервью по system design

Если времени мало, я использую такой скрипт:

“The goal is X.
The main constraint is Y.
I’d start with Z architecture to optimise time-to-value.
Primary risks are A and B, so I’d add observability and fallback paths first.
If growth hits threshold T, I’d split module M into a service.
That gives us a controlled path from speed to scale.”
[Цель — X.
Ключевое ограничение — Y.
Я бы начал с архитектуры Z, чтобы оптимизировать time-to-value.
Основные риски — A и B, поэтому сначала добавил бы observability и fallback-пути.
Если рост достигает порога T, я бы выделил модуль M в отдельный сервис.
Это даёт управляемый путь от скорости к масштабу.]

Ясно.
Защитимо.
Операционно.


Для соседнего фрейминга я сначала фиксирую практическое правило: RAG-архитектура работает только когда мы признаём ограничения retrieval, качество данных и пути отказа, а не притворяемся, будто модель заполнит структурные дыры.
И архитектурные решения остаются поддерживаемыми только если документы доступны для поиска, именование прозрачно, а trade-off прослеживаются во времени.
Если нужен лонг-форм контекст, эта глава естественно сочетается с [RAG without fantasy](../ai_about_ai/17_knowledge_systems_rag_without_fantasy.md) и [searchability and clarity](../ai_about_ai/20_knowledge_systems_searchability_and_clarity.md): качество архитектуры в основном функция явных ограничений и трассируемых решений.

Английская версия главы: [System Architecture in Plain Terms: Time, Cost, Risk](../ai_interview_prep/05_system_architecture_in_plain_terms_time_cost_risk.md).
