# Next.js фронтенд-сценарии: hydration, caching и стабильность UI

Я усвоил это дорогим способом.
Фронтенд может выглядеть быстрым на staging и всё равно ломаться под реальным трафиком.
Обычно не потому, что React слабый.
А потому, что state, режим рендеринга и политика кеширования были выбраны без модели отказов.

Поэтому на вопросах по Next.js я держу одну структуру.
Контекст.
Ограничение.
Выбор.
Последствие.

Если я пропускаю один из пунктов, ответ звучит гладко и пусто.

Первое решение — стратегия рендеринга.
Я сразу привязываю её к бизнес-требованиям:

- SSR, когда данные должны быть свежими на каждый запрос и важен SEO.
- ISR, когда страница может быть слегка устаревшей в контролируемом окне.
- Static generation, когда данные меняются редко и доминирует скорость доставки.
- Client-side fetching, когда персонализация высокая, а индексируемость не является главным требованием.

Это аккуратная теория.
В продакшене страницы почти всегда гибридные.
Одной странице часто нужен статический shell, критичные данные с сервера и клиентские обновления для «живых» виджетов.
“I’m not convinced by ideological purity here.” [Меня не убеждает идеологическая чистота в этом вопросе.]
Гибрид обычно практичнее.

## Hydration mismatch: что я проверяю первым

Когда ломается hydration, команды часто лечат симптомы.
Я начинаю с детерминированного рендера.
Сервер и клиент обязаны собрать одинаковое начальное дерево.

Мой быстрый чеклист:

1. Не используем ли мы недетерминированные значения во время рендера (`Date.now()`, случайные ID, форматирование, зависящее от locale)?
2. Не вызываются ли browser-only API до mount (`window`, `localStorage`, media queries)?
3. Не зависит ли условный рендер на первом paint от client-only контекста?
4. Не создают ли async-границы разные fallback-деревья на сервере и клиенте?

Практический паттерн фикса:

```tsx
const [mounted, setMounted] = useState(false);

useEffect(() => {
  setMounted(true);
}, []);

if (!mounted) return null; // или детерминированный skeleton

return <ThemeSensitiveWidget />;
```

Это не серебряная пуля.
Это контролируемый компромисс.
Сначала защищаем целостность hydration, потом улучшаем perceived loading за счёт стабильных placeholder-ов.

## Решения по caching, которые я могу защитить на интервью

Я считаю caching продуктовым решением, а не только флагом фреймворка.
Важны три вопроса:

- Какую степень устаревания пользователь готов принять?
- Какова цена устаревших данных?
- Какова цена пересчёта на каждый запрос?

В терминах App Router я обычно объясняю так:

```ts
// пример: каталог может быть немного устаревшим
fetch('https://api.example.com/products', {
  next: { revalidate: 60 },
});
```

Или для действительно динамичных endpoint-ов:

```ts
fetch('https://api.example.com/account', {
  cache: 'no-store',
});
```

Интервьюеру обычно меньше важна память на синтаксис.
Важнее, могу ли я объяснить, почему у одного маршрута `revalidate: 60`, а у другого кеш полностью отключён.

## Стабильность UI под нагрузкой

Страница, которая «прыгает» во время взаимодействия, выглядит сломанной, даже если метрики формально терпимые.
Поэтому я проектирую стабильные поверхности.

Что делаю на практике:

- Резервирую место под async-компоненты, чтобы уменьшить layout shift.
- Держу размеры skeleton близкими к финальному контенту.
- Избегаю re-mount больших деревьев, когда меняются только фильтры.
- Debounce для шумных взаимодействий и отмена устаревших запросов.

Для списков я включаю memoization только после профилирования и признаков давления.
Преждевременная memoization — это налог.
Измеренная memoization — инструмент.

## Сценарий, который я использую на интервью

У нас была Next.js-страница с тремя болями:
Hydration warnings, устаревающие виджеты и заметные скачки layout.

Причины были довольно прямые.
Theme-логика зависела от `localStorage` прямо в рендере.
Несколько виджетов использовали ad-hoc client fetch с разной кеш-логикой.
Skeleton-элементы не совпадали по размерам с финальными карточками.

Я провёл чистку в три прохода.

Первый проход: корректность hydration.
Client-only логика ушла за mount-guards.
Серверный рендер стал детерминированным.
Warnings упали до нуля.

Второй проход: cache policy.
Данные каталога перевели на контролируемый revalidation.
Аккаунтные панели ушли в no-store.
Поведение «иногда stale» стало намеренным и документированным.

Третий проход: стабильность layout.
Общие skeleton primitives заменили разрозненные заглушки.
CLS улучшился, но главное — жалобы пользователей прекратились.

Компромисс: мы потратили один спринт на «внутреннюю» инфраструктуру, а не на видимые фичи.
Результат: стало меньше инцидентного шума, выше доверие к фронтенду, быстрее релиз-ревью.
Обычно это окупается.

## Шаблон ответа для интервью: SSR vs ISR vs CSR

Если времени мало, отвечаю одним дыханием:

“I choose by freshness, personalization, and indexability.
If data must be fresh per request, SSR.
If slight staleness is acceptable, ISR with explicit revalidate windows.
If content is highly user-specific and SEO is secondary, client fetching.
Then I verify hydration stability and cache invalidation paths before scaling traffic.”
[Я выбираю по свежести данных, персонализации и индексируемости.
Если данные должны быть свежими на каждый запрос — SSR.
Если допустима лёгкая устарелость — ISR с явным окном revalidate.
Если контент сильно персонализирован, а SEO вторичен — client fetching.
После этого я проверяю стабильность hydration и пути invalidation кеша до масштабирования трафика.]

Спокойно.
Конкретно.
Операционно.


Для соседней глубины я держу два принципа в явном виде: качество контекста определяет фронтенд-решения, поэтому режим рендеринга и cache policy должны совпадать с реальными пользовательскими ограничениями, а не с модой фреймворка.
И стабильный ритм поставки критичен — маленькие, частые релизы выявляют регрессии по hydration и стабильности рано, пока они не стали дорогими инцидентами.
Если нужен расширенный фрейминг, см. [context as operating currency](../ai_about_ai/02_prompt_engineering_context_is_the_new_currency.md) и [ship small daily](../ai_about_ai/10_vibe_coding_ship_small_daily.md): надёжность фронтенда растёт, когда и контекст решений, и cadence поставки зафиксированы явно.

Английская версия главы: [Next.js Frontend Scenarios: Hydration, Caching, and UI Stability](../ai_interview_prep/03_nextjs_frontend_scenarios_hydration_caching_ui_stability.md).
