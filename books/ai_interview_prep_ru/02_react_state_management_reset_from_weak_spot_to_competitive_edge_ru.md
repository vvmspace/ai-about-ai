# Перезапуск React State Management: из слабого места в конкурентное преимущество

Раньше я отвечал на вопросы по React state широко и уверенно, но с тонкой точностью.
Это работает до первого вопроса про границы.
Потом уверенность испаряется.

Поэтому я пересобрал эту область с первых принципов.
Не чтобы пройти викторину.
Чтобы принимать более сильные продакшен-решения под давлением времени.

Вот модель, которой я теперь пользуюсь и на интервью, и в живых проектах.

Локальный UI state отвечает за взаимодействие в пределах одной поверхности фичи.
Глобальный client state отвечает за сквозные UI-задачи между экранами.
Server state отвечает за удалённую «истину», cache policy, retry и синхронизацию.
Derived state вычисляется, а не дублируется.

Если эти четыре слоя смешаны, сложность растёт тихо.
Если они разделены, дефекты становятся диагностируемыми.

Перед тем как писать любой state-код, я прогоняю пять вопросов:

1. Кто владеет источником истины?
2. Кто читает эти данные?
3. Как часто они меняются?
4. Насколько данные могут устареть, прежде чем это заметит пользователь?
5. Как система ведёт себя корректно, если сеть дала сбой?

Этот проход из пяти вопросов убирает большую часть случайной архитектуры.

Помогает простая рабочая карта.
Я держу её в голове во время реализации:

- Открытие/закрытие модалки, hovered row, dirty-флаг формы → локальный `useState`.
- Theme, auth token, пользовательские UI-настройки → компактный глобальный store.
- Список товаров, профиль, счета, лента уведомлений → server state в React Query.
- `filteredProducts`, `isSubmitEnabled`, totals → derived через selectors или memoized вычисления.

Меня не убеждает идея “one store for everything.” [один store для всего.]
Звучит аккуратно.
Стареет плохо.

## Практический пример 1: чистый локальный state

Панель фильтров по умолчанию не требует Redux.
Ей нужно предсказуемое локальное поведение:

```tsx
const [filters, setFilters] = useState({ search: '', status: 'all' });

const onSearchChange = (search: string) =>
  setFilters((prev) => ({ ...prev, search }));

const onStatusChange = (status: 'all' | 'open' | 'closed') =>
  setFilters((prev) => ({ ...prev, status }));
```

Это остаётся внутри границы одного компонента.
Без глобальной связности.
Без «налога на церемонию».

## Практический пример 2: server state через React Query

Server state — место, где многие команды до сих пор переиспользуют `useEffect`.
Я бы этого избегал.

```tsx
const { data, isLoading, isError, refetch } = useQuery({
  queryKey: ['tickets', filters],
  queryFn: () => api.tickets.list(filters),
  staleTime: 30_000,
  retry: 2,
});
```

Теперь cache, loading, retry и refetch выражены явно.
И, что важно, стандартно.
Команда быстро понимает поведение системы.

## Практический пример 3: глобальный state только когда он действительно глобальный

Я держу глобальный state маленьким и очевидным.
Например, UI-предпочтения:

```tsx
import { create } from 'zustand';

type UiState = {
  density: 'compact' | 'comfortable';
  setDensity: (v: UiState['density']) => void;
};

export const useUiStore = create<UiState>((set) => ({
  density: 'comfortable',
  setDensity: (density) => set({ density }),
}));
```

Простое состояние.
Понятное владение.
Минимальная поверхность.

Если домен растёт, а переходы становятся сложнее, Redux Toolkit обычно подходит лучше.
Не потому, что это модно.
Потому что явные reducers и поток actions лучше держат поддержку на масштабе команды.

## Практический пример 4: Redux Toolkit для проверяемых переходов

```tsx
const cartSlice = createSlice({
  name: 'cart',
  initialState: { items: [] as Array<{ id: string; qty: number }> },
  reducers: {
    addItem: (state, action: PayloadAction<{ id: string }>) => {
      const existing = state.items.find((x) => x.id === action.payload.id);
      if (existing) existing.qty += 1;
      else state.items.push({ id: action.payload.id, qty: 1 });
    },
  },
});
```

Для корзин, матриц прав и многошаговых процессов эта явность окупается.

## Два анти-паттерна, которые я теперь отмечаю сразу

Первый — зеркалирование state.
Если API-данные копируются в несколько store «для удобства», расхождение неизбежно.
Рано или поздно один из экранов покажет устаревшую истину.

Второй — оркестрация через эффекты.
Если бизнес-логика зависит от сцепленных цепочек `useEffect`, под нагрузкой появятся тайминговые баги.
“I’d advise against it.” [Я бы этого не рекомендовал.]
Бизнес-решения лучше переносить ближе к event handlers или в выделенные domain-функции.

## Шаблон ответа, безопасный для интервью

Когда спрашивают: “How do you choose between Redux, Zustand, and React Query?” [Как вы выбираете между Redux, Zustand и React Query?], я отвечаю так:

“By ownership and lifecycle.
React Query for server truth and caching.
Local state for isolated interaction.
Global store only for shared client concerns.
Redux Toolkit when transitions and auditability matter.
If we mix these concerns, complexity grows and defect triage slows.”
[По владению и жизненному циклу.
React Query — для серверной истины и кэширования.
Локальный state — для изолированного взаимодействия.
Глобальный store — только для общих клиентских задач.
Redux Toolkit — когда важны переходы состояния и аудируемость.
Если смешивать эти зоны, сложность растёт, а разбор дефектов замедляется.]

Коротко.
Защитимо.
По-senior.

## Реальный сценарий, который можно рассказать за 60–90 секунд

У нас был dashboard с polling, фильтрами таблицы и кросс-страничными предпочтениями.
Изначально команда хранила API-коллекции в Redux и одновременно копировала их в component state.
Пошли hydration-проблемы и stale-data баги.

Я предложил reset.
Серверные коллекции переехали в React Query.
Фильтры остались локальными.
Пользовательские предпочтения — глобальными.
Мы убрали зеркалирование state и заменили ad-hoc эффекты на явную invalidation стратегию для query.

Компромисс: рефактор занял больше времени, чем «быстрый патч».
Результат: stale-data багов стало меньше, шум повторных рендеров снизился, а онбординг новых инженеров ускорился, потому что архитектура стала читаемой.

## Стратегия тестирования, которая звучит практично, а не академично

Я разделяю тесты по риску:

- Reducers/selectors: детерминированные unit-тесты.
- Query hooks: integration-тесты с моками сетевых задержек и краевыми отказами.
- Критический пользовательский путь: один-два end-to-end сценария.

Time. Cost. Risk. [Время. Стоимость. Риск.]
Эта триада удерживает тест-план в реальности.

Ключевой сдвиг психологический.
Я больше не защищаю «идентичность» инструмента.
Я защищаю владение данными, поведение при отказах и поддерживаемость под реальными ограничениями.
Обычно именно это интервьюеры и измеряют.


Для соседнего контекста я держу один принцип на виду: качество рождается из коротких циклов оценки с явными проверками, а не из одной «гениальной» первой попытки.
А когда появляются сбои, я отлаживаюсь вместе с моделями через сужение области, проверку гипотез и изоляцию одной переменной за раз — это та же дисциплина, что мы применяем к state-регрессиям.
Если нужно углубление, см. [evaluation loops in AI-assisted engineering](../ai_about_ai/05_prompt_engineering_evaluation_loops.md) и [debugging with models](../ai_about_ai/08_vibe_coding_debugging_with_models.md).

Английская версия главы: [React State Management Reset: From Weak Spot to Competitive Edge](../ai_interview_prep/02_react_state_management_reset_from_weak_spot_to_competitive_edge.md).
