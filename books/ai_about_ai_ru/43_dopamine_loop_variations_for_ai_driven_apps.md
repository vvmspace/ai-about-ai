# Вариации dopamine loop для AI-driven приложений

Скажите «dopamine loop» на продуктовой встрече,
и половина комнаты решит, что речь о манипуляции.
Это звучит слишком оптимистично.

Большинство продуктов проваливаются по более прозаичной причине:
они не создают инерцию.
Пользователь делает одно действие,
получает один результат,
и затем исчезает.

В **AI-driven apps** удержание редко умирает из-за слабой модели.
Оно умирает, потому что цикл оборвался слишком рано.

Здоровый цикл — это не компульсия.
Это управляемый прогресс при ясной агентности пользователя.

## Базовый цикл, который должна отрисовать каждая команда

Начните с четырёх шагов:

1. trigger,
2. action,
3. reward,
4. следующий micro-commitment.

Если четвёртый шаг расплывчат,
новизна выдыхается,
а использование схлопывается.

## Вариация 1: competence loop

Лучше всего подходит для:
обучения,
продуктивности
и инструментов развития навыков.

Последовательность:

- Trigger: «Мне нужна помощь прямо сейчас».
- Action: пользователь выполняет задачу с поддержкой ИИ.
- Reward: измеримое улучшение,
  а не просто приятный ответ.
- Recommitment: следующий, чуть более сложный вызов.

Почему это работает:
пользователь чувствует себя *сильнее*, а не просто развлечённым.

Риск:
гипер-помощь, которая убирает усилие.
Нет усилия — нет устойчивого обучения.

## Вариация 2: progress-visibility loop

Лучше всего подходит для:
долгих проектов с отложенным результатом.

Последовательность:

- Trigger: незавершённая цель остаётся видимой.
- Action: закрыть один маленький milestone.
- Reward: видимый прогресс + конкретный выигрыш.
- Recommitment: следующий milestone уже поставлен в очередь.

Почему это работает:
видимый прогресс снижает когнитивное сопротивление.

Риск:
фальшивые индикаторы прогресса.
Пользователь это считывает,
и доверие испаряется быстро.

## Вариация 3: social-proof loop

Лучше всего подходит для:
creator-сценариев и профессиональных сообществ.

Последовательность:

- Trigger: пользователь публикует результат.
- Action: коллеги реагируют, сравнивают, дают benchmark.
- Reward: признание + сигнал, что именно улучшать.
- Recommitment: доработать и опубликовать снова.

Почему это работает:
внешняя обратная связь ускоряет итерации.

Риск:
динамика унижения.
Сравнение должно информировать,
а не наказывать.

## Вариация 4: uncertainty-reduction loop

Лучше всего подходит для:
high-stakes сценариев, где тревога блокирует действие.

Последовательность:

- Trigger: «Я вообще делаю это правильно?»
- Action: запрос диагностической подсказки.
- Reward: карта рисков и следующий безопасный шаг.
- Recommitment: выполнить одно стабилизирующее действие.

Почему это работает:
ясность снижает эмоциональный шум.

Риск:
ложная определённость.
Когда уверенность завышена,
ущерб неизбежен.

## Вариация 5: identity loop

Лучше всего подходит для:
продуктов привычек и долгого изменения поведения.

Последовательность:

- Trigger: идентичностная рамка («Я из тех, кто…»).
- Action: выполнить micro-task, согласованный с этой идентичностью.
- Reward: streak, привязанный к идентичности,
  а не к сырой активности в приложении.
- Recommitment: заранее зафиксированное действие на завтра.

Почему это работает:
люди защищают идентичность упорнее, чем чеклисты.

Риск:
стыдящее сообщение.
Это не обсуждается.

## Ограничители, которые действительно не подлежат торгу

Для ясности:
если ваш цикл увеличивает usage, но снижает автономию,
вы строите риск,
а не ценность.

Минимальный набор защит:

- пауза и reset в одно нажатие,
- прозрачная логика персонализации,
- простой opt-out от engagement-подталкиваний,
- wellbeing-напоминания в интенсивных сценариях,
- внутренний review на влияние для уязвимых групп.

Если фича не проходит эти проверки,
она не готова.

## Практическая design-сетка для review фич

Для каждой фичи команда обязана зафиксировать:

- тип цикла,
- целевую награду,
- потенциал злоупотребления,
- метрику успеха,
- границу wellbeing,
- триггер отката.

Звучит жёстко.
Отлично.
Жёсткость предотвращает дорогие ошибки.

## Быстрый ритм внедрения

Неделя 1:
картируйте текущие циклы и найдите тупики.

Неделя 2:
прототипируйте по одному более здоровому recommitment
для каждого ключевого пользовательского пути.

Неделя 3:
выпустите на маленькую когорту и мониторьте качество поведения,
а не только time-in-app.

Неделя 4:
удалите любой паттерн, который поднимает retention,
но портит пользовательские результаты.

Retention без доверия недолговечен.
Доверие с прогрессом накапливается.

Для связанного контекста смотрите
[AI-driven приложения: что меняется в дизайне продукта](./37_ai_driven_apps_what_changes_in_product_design.md)
и [Механики удержания в AI-driven приложениях](./38_user_engagement_mechanics_in_ai_driven_apps.md).

Практический вывод:
**dopamine loops в AI-продуктах** — это инструмент дизайна.
Используйте его, чтобы усиливать способность,
снижать неопределённость
и создавать инерцию, которую пользователь рад продолжать.

Оригинал главы на английском: [Dopamine Loop Variations for AI-Driven Apps](../ai_about_ai/43_dopamine_loop_variations_for_ai_driven_apps.md).
