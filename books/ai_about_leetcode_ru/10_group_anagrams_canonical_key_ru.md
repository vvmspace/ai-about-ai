# 10. Group Anagrams: канонический ключ для группировки

На интервью эта задача выглядит безобидно. Через три минуты становится ясно, кто контролирует модель данных, а кто просто перебирает строки.

Ключевая идея: у анаграмм должен быть один и тот же **канонический ключ**.
Есть два рабочих пути:
- сортировать символы строки и использовать результат как ключ;
- считать частоты букв и кодировать их в компактный профиль.

Первый путь проще объяснить. Второй часто быстрее на длинных строках фиксированного алфавита.

Сложность для подхода с сортировкой:
- время: **O(n * k log k)**, где `n` — число слов, `k` — длина слова;
- память: **O(n * k)** на хранение групп.

Неочевидные термины:
- **canonical representation** — единое представление разных входов, если они эквивалентны;
- **stable grouping key** — ключ, который детерминированно отправляет элемент в нужную группу;
- **collision domain** — пространство, где разные объекты могут случайно получить одинаковый ключ.

Пример на JavaScript:

```javascript
function groupAnagrams(strs) {
  const groups = new Map();

  for (const word of strs) {
    const key = [...word].sort().join('');

    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(word);
  }

  return [...groups.values()];
}
```

Интервью-ответ:

> “I normalise each word into a canonical key and group by that key in a hash map. The key design is the core decision: sorted string for clarity, frequency vector for tighter control over constants.”  
> [«Я нормализую каждое слово в канонический ключ и группирую по этому ключу через hash map. Дизайн ключа — главное решение: отсортированная строка для ясности, вектор частот для лучшего контроля констант».]

Пара фраз:
- “Normalise first, group second.”  
  [«Сначала нормализуй, потом группируй».]
- “A weak key breaks a strong algorithm.”  
  [«Слабый ключ ломает сильный алгоритм».]

Где это в работе: дедупликация поисковых запросов, группировка похожих тегов, приведение пользовательского ввода к единому индексу.

И да, это десятая глава. Вы уже прошли фундаментальные паттерны массива, строки, списка и бинарного поиска. Дальше станет плотнее, но уже в вашей зоне контроля.

Полезные ссылки:
- [Group Anagrams на LeetCode](https://leetcode.com/problems/group-anagrams/)
- [Глава про Valid Anagram](./07_valid_anagram_frequency_models_ru.md)
- [Оглавление книги](./README.md)
