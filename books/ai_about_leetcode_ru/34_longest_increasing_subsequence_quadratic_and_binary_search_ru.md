# 34. Longest Increasing Subsequence: от квадратичного решения к логарифмическому ускорению

Эта задача часто ломает уверенность: кажется, что нужно помнить «секретный трюк». На деле всё спокойнее. Сначала вы строите корректную модель, потом аккуратно ускоряете её.

Базовая версия — dynamic programming (динамическое программирование):
- `dp[i]` — длина лучшей возрастающей подпоследовательности, которая заканчивается в позиции `i`;
- для каждого `i` смотрим все `j < i`;
- если `nums[j] < nums[i]`, обновляем `dp[i] = max(dp[i], dp[j] + 1)`.

Сложность базовой версии:
- время: **O(n²)**;
- память: **O(n)**.

Ускоренная версия использует бинарный поиск (binary search):
- держим массив `tails`, где `tails[len]` — минимальный возможный хвост подпоследовательности длины `len + 1`;
- для каждого числа ищем первую позицию в `tails`, где элемент не меньше текущего;
- заменяем значение или добавляем в конец.

Сложность ускоренной версии:
- время: **O(n log n)**;
- память: **O(n)**.

Термины:
- **subsequence** — подпоследовательность без требования непрерывности;
- **state transition** — правило перехода между состояниями в динамическом программировании;
- **minimal tail invariant** — инвариант минимального хвоста для каждой длины.

Пример на Python (ускоренная версия):

```python
from bisect import bisect_left
from typing import List


def length_of_lis(nums: List[int]) -> int:
    tails: List[int] = []

    for x in nums:
        pos = bisect_left(tails, x)
        if pos == len(tails):
            tails.append(x)
        else:
            tails[pos] = x

    return len(tails)
```

Интервью-ответ:

> “I can present both solutions: quadratic dynamic programming for clarity, then a binary-search optimization with minimal tails for O(n log n). That shows correctness first and scaling second.”  
> [«Я могу показать обе версии: квадратичное динамическое программирование для прозрачности, затем оптимизацию через бинарный поиск и минимальные хвосты до O(n log n). Это демонстрирует сначала корректность, затем масштабирование».]

Две фразы для фиксации:
- “First prove. Then optimise.”  
  [«Сначала докажи. Потом оптимизируй».]
- “Minimal tails, maximal control.”  
  [«Минимальные хвосты, максимальный контроль».]

Рабочая параллель: вы сначала строите надёжную модель ранжирования, а затем переводите её на более эффективный индексный доступ без потери корректности.

Теперь приятный эффект: вы не «угадываете продвинутый алгоритм», вы показываете инженерную эволюцию решения. Это звучит сильно и убедительно.

Полезные ссылки:
- [Longest Increasing Subsequence на LeetCode](https://leetcode.com/problems/longest-increasing-subsequence/)
- [Глава про Word Break](./33_word_break_dp_dictionary_boundary_ru.md)
- [Оглавление книги](./README.md)
