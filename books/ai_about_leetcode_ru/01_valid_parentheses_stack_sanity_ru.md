# 01. Valid Parentheses: стек без магии

Есть ловушка, в которую попадают даже сильные кандидаты: задача кажется «детской», и человек выключает дисциплину. **Valid Parentheses** как раз такая. Формально — просто проверить, корректна ли строка из скобок. По факту — это проверка, умеете ли вы держать состояние и не путать локальную валидность с глобальной.

Наивная мысль обычно такая: «Посчитаю количество `(` и `)`». Увы, это не работает. Строка `)(` имеет нулевой баланс, но она невалидна. Значит, нам нужен не только счётчик, а порядок. И вот здесь появляется стек.

Идея простая: открывающие скобки кладём в стек, закрывающую — сопоставляем с вершиной. Если вершина не подходит или стек пуст, строка невалидна.

Сложность тоже нужно проговаривать явно:
- время: **O(n)**, мы идём по строке один раз;
- память: **O(n)** в худшем случае, если все скобки открывающие.

Неочевидные термины, которые полезно знать:
- **LIFO** (*Last In, First Out*) — режим работы стека: последним вошёл, первым вышел;
- **ранний выход** (*early exit*) — прекращение алгоритма сразу после обнаружения нарушения;
- **pushdown automaton** — формальная модель, объясняющая, почему для вложенных структур нужен стек, а не просто счётчики.

Пример на Go:

```go
package main

func isValid(s string) bool {
	pairs := map[rune]rune{')': '(', ']': '[', '}': '{'} // Соответствия закрывающих скобок.
	stack := make([]rune, 0, len(s))

	for _, ch := range s {
		// Если это закрывающая скобка, проверяем вершину стека.
		if open, isClosing := pairs[ch]; isClosing {
			if len(stack) == 0 {
				return false // Early exit: закрывающая скобка без пары.
			}

			top := stack[len(stack)-1]
			if top != open {
				return false // Тип скобки не совпал.
			}

			stack = stack[:len(stack)-1] // Pop.
			continue
		}

		// Иначе это открывающая скобка, кладём в стек.
		stack = append(stack, ch) // Push.
	}

	return len(stack) == 0 // Стек должен быть пуст в конце.
}
```

И коротко про сложность в контексте кода:
- каждый символ участвует максимум в одном `push` и одном `pop`;
- поэтому количество операций линейно от длины строки;
- memory footprint растёт вместе с глубиной вложенности.

Интервью-формулировка, которая звучит спокойно и сильно:

> “I model the string as a stream of tokens and keep a stack of unresolved opening brackets. Every closing bracket must match the current top; otherwise I fail fast. That gives linear time with stack-bounded memory.”  
> [«Я моделирую строку как поток токенов и храню в стеке неразрешённые открывающие скобки. Каждая закрывающая должна совпасть с вершиной, иначе я сразу завершаю проверку. Это даёт линейное время и память, ограниченную глубиной стека».]

Пара фраз для запоминания:
- “Order matters more than counts.”  
  [«Порядок важнее количества».]
- “I fail fast on structural mismatch.”  
  [«При структурном несовпадении я завершаю проверку сразу».]

Где это встречается в работе: парсинг выражений, валидация JSON/XML, проверка шаблонов конфигураций, анализ лога с вложенными блоками. Везде ключевая мысль одна — баланс без порядка не спасает.

Полезные ссылки:
- [Valid Parentheses на LeetCode](https://leetcode.com/problems/valid-parentheses/)
- [Оглавление книги](./README.md)
