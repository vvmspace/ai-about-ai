# 05. Maximum Subarray: когда локальный выбор работает глобально

У этой задачи есть коварный эффект: она выглядит как brute-force на все подмассивы, и многие так и делают. Работает, но за **O(n²)** или хуже. На интервью это считается техническим долгом в реальном времени.

Ключ — понять, что нам не нужен каждый подмассив. Нам нужен максимум суммы. Алгоритм Kadane хранит два состояния:
- `current` — лучшая сумма подмассива, заканчивающегося в текущей позиции;
- `best` — глобальный максимум среди всех позиций.

Переход:
`current = max(x, current + x)`

То есть мы решаем: выгодно продолжать старый отрезок или лучше начать новый с текущего элемента.

Сложность:
- время: **O(n)**;
- память: **O(1)**.

Неочевидные термины:
- **prefix-optimal state** — локально оптимальное состояние на префиксе;
- **restart condition** — критерий перезапуска подмассива;
- **state transition** — формула перехода между соседними позициями.

Пример на Python:

```python
def max_sub_array(nums):
    current = nums[0]  # Лучшая сумма подмассива, заканчивающегося здесь.
    best = nums[0]     # Глобально лучшая сумма.

    for x in nums[1:]:
        # Либо продолжаем текущий отрезок, либо стартуем заново с x.
        current = max(x, current + x)

        # Обновляем глобальный максимум.
        if current > best:
            best = current

    return best
```

Интервью-ответ:

> “I keep a local optimum for subarrays ending at each index and a global optimum across all indices. The transition decides between extension and restart, giving linear time with constant memory.”  
> [«Я храню локальный оптимум для подмассивов, заканчивающихся в каждой позиции, и глобальный оптимум по всем позициям. Переход выбирает между продолжением и перезапуском, что даёт линейное время и константную память».]

Пара фраз:
- “Local optimality drives global result here.”  
  [«Здесь локальная оптимальность ведёт к глобальному результату».]
- “Restart is not a hack; it is the invariant.”  
  [«Перезапуск — не трюк, а часть инварианта».]

В работе это встречается в анализе KPI-окна, поиске лучшего непрерывного периода выручки, оценке наиболее стабильного промежутка сигнала.

Дофаминовый момент на пятой главе: вы только что собрали первый блок базовых паттернов, и теперь можете решать задачи не «по памяти», а по состояниям и инвариантам.

Полезные ссылки:
- [Maximum Subarray на LeetCode](https://leetcode.com/problems/maximum-subarray/)
- [Оглавление книги](./README.md)
